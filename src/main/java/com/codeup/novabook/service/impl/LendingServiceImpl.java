/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.codeup.novabook.service.impl;

import com.codeup.novabook.domain.Lending;
import com.codeup.novabook.repository.LendingRepository;
import com.codeup.novabook.repository.jdbc.LendingRepositoryJDBC;
import com.codeup.novabook.service.LendingService;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Optional;

/**
 * Service implementation for Lending business logic operations.
 * Handles book lending, returns, and lending management.
 * 
 * @author Adrián Gutiérrez
 */
public class LendingServiceImpl implements LendingService {
    
    private final LendingRepository lendingRepository;
    private static final int DEFAULT_LENDING_DAYS = 14;
    private static final int DEFAULT_MAX_BOOKS = 3;
    
    /**
     * Constructor that initializes the lending repository.
     */
    public LendingServiceImpl() {
        this.lendingRepository = new LendingRepositoryJDBC();
    }
    
    @Override
    public Lending lendBook(int memberId, int bookId, int lendingDays) {
        if (memberId <= 0) {
            throw new IllegalArgumentException("Member ID must be positive");
        }
        if (bookId <= 0) {
            throw new IllegalArgumentException("Book ID must be positive");
        }
        if (lendingDays <= 0) {
            lendingDays = DEFAULT_LENDING_DAYS;
        }
        
        // Check if member can borrow more books
        if (!canMemberBorrowMoreBooks(memberId, DEFAULT_MAX_BOOKS)) {
            throw new IllegalArgumentException("Member has reached the maximum number of borrowed books");
        }
        
        // Check if book is currently available (not lent out)
        if (isBookCurrentlyLent(bookId)) {
            throw new IllegalArgumentException("Book is currently lent out and not available");
        }
        
        Instant now = Instant.now();
        Instant dueDate = now.plus(lendingDays, ChronoUnit.DAYS);
        
        Lending lending = new Lending(
            0, // ID will be generated by database
            memberId,
            bookId,
            now,
            dueDate,
            false, // not returned
            now,
            now
        );
        
        return lendingRepository.save(lending);
    }
    
    @Override
    public boolean returnBook(int lendingId) {
        if (lendingId <= 0) {
            throw new IllegalArgumentException("Lending ID must be positive");
        }
        
        return lendingRepository.markAsReturned(lendingId);
    }
    
    @Override
    public Optional<Lending> findLendingById(int id) {
        if (id <= 0) {
            throw new IllegalArgumentException("Lending ID must be positive");
        }
        return lendingRepository.findById(id);
    }
    
    @Override
    public List<Lending> getAllLendings() {
        return lendingRepository.findAll();
    }
    
    @Override
    public List<Lending> getLendingsByMember(int memberId) {
        if (memberId <= 0) {
            throw new IllegalArgumentException("Member ID must be positive");
        }
        return lendingRepository.findByMemberId(memberId);
    }
    
    @Override
    public List<Lending> getLendingsByBook(int bookId) {
        if (bookId <= 0) {
            throw new IllegalArgumentException("Book ID must be positive");
        }
        return lendingRepository.findByBookId(bookId);
    }
    
    @Override
    public List<Lending> getActiveLendings() {
        return lendingRepository.findByReturned(false);
    }
    
    @Override
    public List<Lending> getOverdueLendings() {
        return lendingRepository.findOverdueLendings(Instant.now());
    }
    
    @Override
    public List<Lending> getLendingsDueBetween(Instant startDate, Instant endDate) {
        if (startDate == null) {
            throw new IllegalArgumentException("Start date cannot be null");
        }
        if (endDate == null) {
            throw new IllegalArgumentException("End date cannot be null");
        }
        if (startDate.isAfter(endDate)) {
            throw new IllegalArgumentException("Start date cannot be after end date");
        }
        
        return lendingRepository.findByDueDateBetween(startDate, endDate);
    }
    
    @Override
    public boolean extendLending(int lendingId, int additionalDays) {
        if (lendingId <= 0) {
            throw new IllegalArgumentException("Lending ID must be positive");
        }
        if (additionalDays <= 0) {
            throw new IllegalArgumentException("Additional days must be positive");
        }
        
        Optional<Lending> lendingOpt = lendingRepository.findById(lendingId);
        if (lendingOpt.isPresent()) {
            Lending lending = lendingOpt.get();
            if (!lending.isReturned()) {
                Instant newDueDate = lending.getDueDate().plus(additionalDays, ChronoUnit.DAYS);
                lending.setDueDate(newDueDate);
                lending.setUpdatedAt(Instant.now());
                lendingRepository.update(lending);
                return true;
            }
        }
        
        return false;
    }
    
    @Override
    public boolean canMemberBorrowMoreBooks(int memberId, int maxBooks) {
        if (memberId <= 0) {
            throw new IllegalArgumentException("Member ID must be positive");
        }
        
        long activeLendingCount = lendingRepository.countByMemberId(memberId);
        return activeLendingCount < maxBooks;
    }
    
    @Override
    public boolean isBookCurrentlyLent(int bookId) {
        if (bookId <= 0) {
            throw new IllegalArgumentException("Book ID must be positive");
        }
        
        List<Lending> activeLendings = lendingRepository.findByBookId(bookId);
        return activeLendings.stream().anyMatch(lending -> !lending.isReturned());
    }
    
    @Override
    public double calculateFine(int lendingId, double dailyFineRate) {
        if (lendingId <= 0) {
            throw new IllegalArgumentException("Lending ID must be positive");
        }
        if (dailyFineRate < 0) {
            throw new IllegalArgumentException("Daily fine rate cannot be negative");
        }
        
        Optional<Lending> lendingOpt = lendingRepository.findById(lendingId);
        if (lendingOpt.isPresent()) {
            Lending lending = lendingOpt.get();
            
            if (lending.isReturned()) {
                return 0.0; // No fine if already returned
            }
            
            Instant now = Instant.now();
            if (now.isAfter(lending.getDueDate())) {
                long overdueDays = ChronoUnit.DAYS.between(lending.getDueDate(), now);
                return overdueDays * dailyFineRate;
            }
        }
        
        return 0.0;
    }
    
    @Override
    public long getLendingCount() {
        return lendingRepository.count();
    }
    
    @Override
    public long getActiveLendingCount() {
        return lendingRepository.countActiveLendings();
    }
    
    @Override
    public long getLendingCountByMember(int memberId) {
        if (memberId <= 0) {
            throw new IllegalArgumentException("Member ID must be positive");
        }
        return lendingRepository.countByMemberId(memberId);
    }
}
